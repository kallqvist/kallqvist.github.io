var v=Object.defineProperty;var P=(r,t,e)=>t in r?v(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var x=(r,t,e)=>(P(r,typeof t!="symbol"?t+"":t,e),e),W=(r,t,e)=>{if(!t.has(r))throw TypeError("Cannot "+e)};var w=(r,t,e)=>(W(r,t,"read from private field"),e?e.call(r):t.get(r)),S=(r,t,e)=>{if(t.has(r))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(r):t.set(r,e)},M=(r,t,e,n)=>(W(r,t,"write to private field"),n?n.call(r,e):t.set(r,e),e);import{r as p,j as C}from"./index-DSvTwJ02.js";function F(r){const[t,e]=p.useState(r),n=p.useRef(t);return[n,s=>{s instanceof Function?(n.current=s(n.current),e(s)):(n.current=s,e(s))}]}class D{constructor(t){x(this,"grid");x(this,"index");x(this,"position");x(this,"dir",{NW:()=>this.getNeighbourInDirection(o.NW),N:()=>this.getNeighbourInDirection(o.N),NE:()=>this.getNeighbourInDirection(o.NE),E:()=>this.getNeighbourInDirection(o.E),SE:()=>this.getNeighbourInDirection(o.SE),S:()=>this.getNeighbourInDirection(o.S),SW:()=>this.getNeighbourInDirection(o.SW),W:()=>this.getNeighbourInDirection(o.W)});this.grid=t,this.index=-1,this.position=new i(0,0)}getNeighbourInDirection(t){if(this.position)return this.grid.getAtPosition(this.position.add(t))}getNeighbourhood(){const t=[];return G.forEach(e=>{const n=this.getNeighbourInDirection(e);t.push(n)}),t}getLineTo(t,e){return this.grid.getPositionsInLine(this.position,t,e)}swapWith(t){this.grid.swap(this,t)}getRGBA(){return[0,0,0,0]}}var m,E;class L{constructor(t){x(this,"width");x(this,"height");x(this,"alternateRows");x(this,"createEmpty");S(this,m,void 0);S(this,E,void 0);const{width:e,height:n,alternateRows:a,createEmpty:s}={alternateRows:!1,...t};M(this,m,[]),M(this,E,new Set([])),this.width=e,this.height=n,this.alternateRows=a,this.createEmpty=s,this.clear()}clear(){for(let t=0;t<this.width*this.height;t++)this.setAtIndex(t,this.createEmpty(this))}indexOf(t){return t?t.index:-1}positionOf(t){if(t)return t.position}forEach(t,e){const{alternateRows:n}=e||{},a=new Set,s=w(this,m);let f=(d,u)=>{const h=this.position2index(new i(d,u)),g=s[h];if(!g||a.has(g))return;if(t(g,h)===!1)return!1;a.add(g)};for(let d=0;d<this.height;d++){let u;if(n&&d%2===0&&Math.random()<.5){for(let h=this.width-1;h>=0&&(u=f(h,d),u!==!1);h--);if(u===!1)break;continue}for(let h=0;h<this.width&&(u=f(h,d),u!==!1);h++);if(u===!1)break}}map(t){return w(this,m).map(t)}forEachChanged(t,e=!0){w(this,E).forEach(n=>t(n)),e&&w(this,E).clear()}position2index(t){const{x:e,y:n}=t;return e<0||e>=this.width||n<0||n>=this.height?-1:e+n*this.width}index2position(t){let e=Math.floor(t/this.width),n=t-e*this.width;return new i(n,e)}get(t){return this.getAtPosition(t)}set(t,e){this.setAtPosition(t,e)}getPositionsInLine(t,e,n){const{excludeStart:a,excludeEnd:s}=n||{},f=e.x-t.x,d=e.y-t.y;if(f===0&&d===0)return[t];const u=f<0?-1:1,h=d<0?-1:1,g=Math.abs(f),N=Math.abs(d),I=g>=N,b=Math.min(g,N),c=Math.max(g,N),l=b/c,y=[];for(let R=a?1:0;R<(s?c:c+1);R++){const A=Math.round(R*l);I?y.push(new i(t.x+R*u,t.y+A*h)):y.push(new i(t.x+A*u,t.y+R*h))}return y}getAtPosition(t){const e=this.position2index(t);if(e!==-1)return this.getAtIndex(e)}setAtPosition(t,e){const n=this.position2index(t);this.setAtIndex(n,e)}getAtIndex(t){return w(this,m)[t]}registerChanged(t){w(this,E).add(t)}swap(t,e){const n=this.indexOf(t),a=this.indexOf(e),s=w(this,m)[n];this.setAtIndex(n,w(this,m)[a]),this.setAtIndex(a,s)}setAtIndex(t,e){e.index=t,e.position=this.index2position(t),w(this,m)[t]=e,this.registerChanged(e)}}m=new WeakMap,E=new WeakMap;class i{constructor(t,e){x(this,"x");x(this,"y");this.x=t,this.y=e}clone(){return new i(this.x,this.y)}add(t){return new i(this.x+t.x,this.y+t.y)}multiply(t){return new i(this.x*t.x,this.y*t.y)}multiplyScalar(t){return new i(this.x*t,this.y*t)}divide(t){return new i(this.x/t.x,this.y/t.y)}divideScalar(t){return new i(this.x/t,this.y/t)}round(){return new i(Math.round(this.x),Math.round(this.y))}floor(){return new i(Math.floor(this.x),Math.floor(this.y))}ceil(){return new i(Math.ceil(this.x),Math.ceil(this.y))}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();return t===0?i.zero():this.multiplyScalar(1/t)}dot(t){const e=this.multiply(t);return e.x+e.y}static zero(){return new i(0,0)}static one(){return new i(1,1)}static up(){return new i(0,-1)}static down(){return new i(0,1)}static left(){return new i(-1,0)}static right(){return new i(-1,0)}static random(){return new i(Math.random(),Math.random())}}const o={NW:new i(-1,-1),N:new i(0,-1),NE:new i(1,-1),E:new i(1,0),SE:new i(1,1),S:new i(0,1),SW:new i(-1,1),W:new i(-1,0)},G=[o.NW,o.N,o.NE,o.W,o.E,o.SW,o.S,o.SE];function q(r){const{grid:t,pickColor:e,...n}=r,a=p.useRef(),s=p.useRef(null),f=p.useRef(),[d,u]=F(!0);p.useEffect(()=>(a.current=requestAnimationFrame(I),()=>{a.current!==void 0&&cancelAnimationFrame(a.current)}),[]),p.useEffect(()=>{t&&(u(!0),N(),I())},[t]);function h(){return s.current?s.current.getContext("2d"):null}function g(){if(f.current)return f.current;if(!t)return;const c=h();if(c)return f.current=c.createImageData(t.width,t.height),f.current}function N(){const c=g();c&&(c.data.fill(0),u(!0))}function I(){if(!t)return;const c=h();if(!c)return;const l=g();l&&(d.current===!0?t.forEach(y=>b(l,y)):t.forEachChanged(y=>b(l,y)),c.putImageData(l,0,0),u(!1),a.current=requestAnimationFrame(I))}function b(c,l){l.index!==-1&&t&&c.data.set(e?e(l):l.getRGBA(),l.index*4)}return t?C.jsx("div",{className:"grid canvas",children:C.jsx("canvas",{ref:s,width:t.width,height:t.height,...n})}):null}export{D as G,i as V,L as a,q as b,G as n,F as u};
