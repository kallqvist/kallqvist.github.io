var ut=Object.defineProperty;var ct=(r,t,e)=>t in r?ut(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var u=(r,t,e)=>(ct(r,typeof t!="symbol"?t+"":t,e),e),tt=(r,t,e)=>{if(!t.has(r))throw TypeError("Cannot "+e)};var s=(r,t,e)=>(tt(r,t,"read from private field"),e?e.call(r):t.get(r)),x=(r,t,e)=>{if(t.has(r))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(r):t.set(r,e)},c=(r,t,e,i)=>(tt(r,t,"write to private field"),i?i.call(r,e):t.set(r,e),e);var q=(r,t,e)=>(tt(r,t,"access private method"),e);import{r as E,j as et,_ as dt}from"./index-IopWrGjV.js";import"./react-spring_web.modern-EHzEOVvW.js";function ft(r){const[t,e]=E.useState(r),i=E.useRef(t);return[i,a=>{a instanceof Function?(i.current=a(i.current),e(a)):(i.current=a,e(a))}]}class nt{constructor(t){u(this,"grid");u(this,"index");u(this,"position");u(this,"dir",{NW:()=>this.getNeighbourInDirection(p.NW),N:()=>this.getNeighbourInDirection(p.N),NE:()=>this.getNeighbourInDirection(p.NE),E:()=>this.getNeighbourInDirection(p.E),SE:()=>this.getNeighbourInDirection(p.SE),S:()=>this.getNeighbourInDirection(p.S),SW:()=>this.getNeighbourInDirection(p.SW),W:()=>this.getNeighbourInDirection(p.W)});this.grid=t,this.index=-1,this.position=new l(0,0)}getNeighbourInDirection(t){if(this.position)return this.grid.getAtPosition(this.position.add(t))}getNeighbourhood(){const t=[];return mt.forEach(e=>{const i=this.getNeighbourInDirection(e);t.push(i)}),t}getLineTo(t,e){return this.grid.getPositionsInLine(this.position,t,e)}swapWith(t){this.grid.swap(this,t)}getRGBA(){return[0,0,0,0]}}var v,J,it;class st{constructor(t){x(this,J);u(this,"size");u(this,"alternateRows");u(this,"createEmpty");u(this,"grid");x(this,v,void 0);const{size:e,alternateRows:i,createEmpty:o}={alternateRows:!1,...t};this.grid=[],c(this,v,new Set([])),this.size=e,this.alternateRows=i,this.createEmpty=o?()=>o(this):()=>new nt(this),q(this,J,it).call(this)}clear(){q(this,J,it).call(this),this.resetChanges()}indexOf(t){return t?t.index:-1}positionOf(t){if(t)return t.position}forEach(t,e){const{alternateRowDirections:i,evenRows:o,oddRows:a,evenCols:d,oddCols:C,startRow:w,endRow:R,startCol:S,endCol:I}={evenRows:!0,oddRows:!0,evenCols:!0,oddCols:!0,...e},A=new Set,b=(g,N)=>{const h=this.position2index(new l(g,N)),f=this.grid[h];if(!f||A.has(f))return;if(t(f,h)===!1)return!1;A.add(f)};for(let g=w||0;g<(R||this.size.y);g++){const N=g%2;if(N===0&&!o)continue;if(N===1&&!a)continue;let h;if(i&&g%2===0&&Math.random()<.5){for(let f=(I||this.size.x)-1;f>=(S||0);f--){const y=f%2;if(!(y===0&&!d)&&!(y===1&&!C)&&(h=b(f,g),h===!1))break}if(h===!1)break;continue}for(let f=S||0;f<(I||this.size.x);f++){const y=f%2;if(!(y===0&&!d)&&!(y===1&&!C)&&(h=b(f,g),h===!1))break}if(h===!1)break}}map(t){return this.grid.map(t)}mapChanged(t){return this.getAllChanges().map(t)}getAllChanges(){return[...s(this,v).values()]}countChanges(){return s(this,v).size}forEachChanged(t,e=!1){s(this,v).forEach(t),e&&this.resetChanges()}registerChanged(t){t.index<0||t.index>=this.grid.length||s(this,v).has(t)||s(this,v).add(t)}resetChanges(){s(this,v).clear()}position2index(t){const{x:e,y:i}=t;return e<0||e>=this.size.x||i<0||i>=this.size.y?-1:e+i*this.size.x}index2position(t){const e=Math.floor(t/this.size.x),i=t-e*this.size.x;return new l(i,e)}get(t){return this.getAtPosition(t)}set(t,e){this.setAtPosition(t,e)}getPositionsInLine(t,e,i){const{excludeStart:o,excludeEnd:a}=i||{},d=e.x-t.x,C=e.y-t.y;if(d===0&&C===0)return[t];const w=d<0?-1:1,R=C<0?-1:1,S=Math.abs(d),I=Math.abs(C),A=S>=I,b=Math.min(S,I),g=Math.max(S,I),N=b/g,h=[];for(let f=o?1:0;f<(a?g:g+1);f++){const y=Math.round(f*N);A?h.push(new l(t.x+f*w,t.y+y*R)):h.push(new l(t.x+y*w,t.y+f*R))}return h}getAtPosition(t){const e=this.position2index(t);if(e!==-1)return this.getAtIndex(e)}setAtPosition(t,e){const i=this.position2index(t);this.setAtIndex(i,e)}getAtIndex(t){return this.grid[t]}swap(t,e){const i=this.indexOf(t),o=this.indexOf(e);if(i===-1||o===-1)throw new Error("Can't swap unless both cells exists in the grid");const a=this.grid[i];this.setAtIndex(i,this.grid[o]),this.setAtIndex(o,a)}setAtIndex(t,e){if(t<0)throw new Error(`invalid index: ${t}`);e.index=t,e.position=this.index2position(t),this.grid[t]=e,this.registerChanged(e)}}v=new WeakMap,J=new WeakSet,it=function(){const t=this.size.x*this.size.y;this.grid.length=t;for(let e=0;e<t;e++)this.setAtIndex(e,this.createEmpty())};var M,D,G,L;class lt extends nt{constructor(e,i){super(e);u(this,"parent");x(this,M,new Set);x(this,D,void 0);x(this,G,void 0);x(this,L,void 0);this.parent=i}get dirtyRect(){return s(this,L)}forEach(e,i){const o=this.parent.chunkSize,a=this.position.multiply(o),d=this.position.multiply(o).add(o);this.parent.forEach(e,{startRow:a.y,endRow:d.y,startCol:a.x,endCol:d.x,...i})}haveChanges(){return s(this,M).size>0}countChanges(){return s(this,M).size}registerChange(e){s(this,M).has(e)||(s(this,M).add(e),c(this,D,l.min(s(this,D)||l.positiveInfinity,e.position)),c(this,G,l.max(s(this,G)||l.negativeInfinity,e.position)),c(this,L,new yt(s(this,D),s(this,G).subtract(s(this,D)))))}resetChanges(){s(this,M).clear(),c(this,D,void 0),c(this,G,void 0),c(this,L,void 0)}forEachChangedCell(e,i=!1){s(this,M).forEach(e),i&&this.resetChanges()}}M=new WeakMap,D=new WeakMap,G=new WeakMap,L=new WeakMap;function gt(r){return new Worker("/assets/worker-G1OrwRg-.js",{name:r==null?void 0:r.name})}var z,Y,O,K,Z,rt,V,ot,_,ht;class xt extends st{constructor(e){const{chunkSize:i,workerize:o,...a}=e;super(a);x(this,Z);x(this,V);x(this,_);u(this,"chunkSize",new l(64,64));x(this,z,void 0);x(this,Y,void 0);x(this,O,void 0);x(this,K,[]);this.chunkSize=i||new l(64,64),c(this,z,new st({size:this.size.divide(this.chunkSize),createEmpty:d=>new lt(d,this)})),c(this,Y,o||!1),s(this,Y)&&(c(this,O,new gt),s(this,O).onmessage=this.handleWorkerResponse),q(this,Z,rt).call(this)}clear(){super.clear(),this.resetChanges()}registerChanged(e){if(e.index<0||e.index>=this.grid.length)return;const i=this.chunkOf(e);i&&i.registerChange(e)}resetChanges(){super.resetChanges(),this.forEachChunk(e=>e.resetChanges())}countChanges(){return this.mapChunks(e=>e.countChanges()).reduce((e,i)=>e+i)}forEachChanged(e,i){this.forEachChunk(o=>{o.haveChanges()&&o.forEachChangedCell(e,i)})}chunkOf(e){if(!e||!this.chunkSize)return;const i=e.position.divide(this.chunkSize).floor();return s(this,z).get(i)}forEachChunk(e,i){s(this,z).forEach(e,i)}mapChunks(e){return s(this,z).map(e)}forEachChangedChunkPass(e,i=!1){this.forEachChunkPass(o=>{const a=o.filter(d=>d.haveChanges());a.length!==0&&(e(a),i&&a.forEach(d=>d.resetChanges()))})}forEachChunkPass(e){s(this,K).forEach((i,o)=>{s(this,Y)?q(this,_,ht).call(this,()=>e(i,o)):e(i,o)})}handleWorkerResponse(e){console.log("worker says:",this,e.data)}}z=new WeakMap,Y=new WeakMap,O=new WeakMap,K=new WeakMap,Z=new WeakSet,rt=function(){for(let e=0;e<s(this,z).size.x*s(this,z).size.y;e++)s(this,z).setAtIndex(e,s(this,z).createEmpty());q(this,V,ot).call(this)},V=new WeakSet,ot=function(){const e=[[!1,!1],[!1,!0],[!0,!1],[!0,!0]],i=[];e.forEach(([o,a])=>{const d=[];this.forEachChunk(C=>{d.push(C)},{evenRows:!o,oddRows:o,evenCols:!a,oddCols:a}),i.push(d)}),c(this,K,i)},_=new WeakSet,ht=function(e){s(this,O)&&s(this,O).postMessage({f:e})};class yt{constructor(t,e){u(this,"position");u(this,"size");this.position=t,this.size=e}toArray(){return[...this.position.toArray(),...this.size.toArray()]}}const n=class n{constructor(t=0,e=0){u(this,"x");u(this,"y");this.x=t,this.y=e}clone(){return new n(this.x,this.y)}add(t){return new n(this.x+t.x,this.y+t.y)}addScalar(t){return new n(this.x+t,this.y+t)}subtract(t=n.zero){return new n(this.x-t.x,this.y-t.y)}subtractScalar(t){return new n(this.x-t,this.y-t)}multiply(t){return new n(this.x*t.x,this.y*t.y)}multiplyScalar(t){return new n(this.x*t,this.y*t)}divide(t){return new n(this.x/t.x,this.y/t.y)}divideScalar(t){return new n(this.x/t,this.y/t)}mod(t){return new n(this.x%t.x,this.y%t.y)}modScalar(t){return new n(this.x%t,this.y%t)}abs(){return new n(Math.abs(this.x),Math.abs(this.y))}round(){return new n(Math.round(this.x),Math.round(this.y))}floor(){return new n(Math.floor(this.x),Math.floor(this.y))}ceil(){return new n(Math.ceil(this.x),Math.ceil(this.y))}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();return t===0?n.zero:this.multiplyScalar(1/t)}dot(t){const e=this.multiply(t);return e.x+e.y}isEqual(t){return this.x===t.x&&this.y===t.y}isNear(t,e=.001){const i=this.subtract(t).abs();return i.x<=e&&i.y<=e}toArray(){return[this.x,this.y]}join(t){return this.toArray().join(t)}static min(t,e){return new n(Math.min(t.x,e.x),Math.min(t.y,e.y))}static max(t,e){return new n(Math.max(t.x,e.x),Math.max(t.y,e.y))}static fromArray([t,e]){return new n(t,e)}static random(){return new n(Math.random(),Math.random())}};u(n,"zero",new n),u(n,"one",new n(1,1)),u(n,"up",new n(0,-1)),u(n,"down",new n(0,1)),u(n,"left",new n(-1,0)),u(n,"right",new n(1,0)),u(n,"negativeInfinity",new n(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)),u(n,"positiveInfinity",new n(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY));let l=n;const p={NW:new l(-1,-1),N:new l(0,-1),NE:new l(1,-1),E:new l(1,0),SE:new l(1,1),S:new l(0,1),SW:new l(-1,1),W:new l(-1,0)},mt=[p.NW,p.N,p.NE,p.W,p.E,p.SW,p.S,p.SE];class zt{constructor(t){u(this,"grid");const{gridOptions:e}=t;this.grid=this.createGrid(e)}clear(){this.grid.clear()}}function pt(r,t){const{children:e,grid:i,debugDraw:o,pickColor:a,...d}={debugDraw:!1,...r},C=E.useRef(null),w=E.useRef(),[R,S]=ft(!0);E.useImperativeHandle(t,()=>({clear:b,render:g})),E.useEffect(()=>{i&&(b(),g(i))},[i]);function I(){return C.current?C.current.getContext("2d"):null}function A(){if(w.current)return w.current;if(!i)return;const h=I();if(h)return w.current=h.createImageData(...i.size.toArray()),w.current}function b(){const h=A();h&&(h.data.fill(0),S(!0))}function g(h,f={debugDraw:o}){const{debugDraw:y,resetChanges:Q}={debugDraw:!1,resetChanges:!1,...f};if(!h)return;const m=I();if(!m)return;const U=A();U&&(R.current===!0?h.forEach($=>N({imageData:U,cell:$})):h.forEachChanged($=>N({imageData:U,cell:$}),Q),m.putImageData(U,0,0),y&&h instanceof xt&&h.forEachChunkPass(($,at)=>{$.forEach(F=>{m.strokeStyle=F.haveChanges()?"white":"rgba(0, 0, 0, 0.2)",m.fillStyle=m.strokeStyle,m.lineWidth=1;const X=F.position.multiply(h.chunkSize);m.strokeRect(...X.toArray(),...h.chunkSize.toArray()),m.textAlign="right",m.fillText(F.position.toArray().toString(),...X.add(h.chunkSize).subtractScalar(2).toArray()),m.textAlign="left",m.fillText(at.toString(),...X.add(h.chunkSize.multiply(l.down).add(l.fromArray([2,-2]))).toArray(),h.chunkSize.x),F.dirtyRect&&(m.strokeStyle="red",m.fillStyle="red",m.textAlign="left",m.fillText(F.countChanges().toString(),...X.add(l.fromArray([2,10])).toArray()),m.strokeRect(...F.dirtyRect.position.toArray(),...F.dirtyRect.size.toArray()))})}),S(!1))}function N(h){const{imageData:f,cell:y}=h;if(y.index===-1)return;const Q=a?a({cell:y}):y.getRGBA();Q&&f.data.set(Q,y.index*4)}if(i)return et.jsxs("div",{className:"grid canvas",children:[et.jsx("canvas",{ref:C,width:i.size.x||1,height:i.size.y||1,...d}),e]})}const wt=E.forwardRef(pt);var P,H,k,B,W,T,j;class Ct{constructor(t){x(this,P,void 0);x(this,H,void 0);x(this,k,void 0);u(this,"limitFps");x(this,B,void 0);x(this,W,!0);x(this,T,void 0);x(this,j,void 0);const{gridRenderer:e,renderOptions:i,simulation:o,limitFps:a,onStep:d}=t;c(this,P,e),c(this,H,i),c(this,k,o),this.limitFps=a,c(this,B,d),this._stepInternal=this._stepInternal.bind(this),c(this,T,requestAnimationFrame(this._stepInternal))}_stepInternal(t){this.step(t),c(this,T,requestAnimationFrame(this._stepInternal))}get simulation(){return s(this,k)}destroy(){var t,e;this.stop(),(t=s(this,k))==null||t.clear(),(e=s(this,P))==null||e.clear(),s(this,T)!==void 0&&cancelAnimationFrame(s(this,T))}start(){s(this,W)||(c(this,W,!0),this._stepInternal(Date.now()))}stop(){c(this,W,!1)}restart(){this.destroy(),this.start()}isRunning(){return s(this,W)}registerSimulation(t){s(this,k)&&(console.error("already have one"),this.destroy()),c(this,k,t)}registerGridRenderer(t,e){c(this,P,t),e&&c(this,H,e)}step(t){if(s(this,j)===void 0)c(this,j,t);else{const e=(t-s(this,j))/1e3;if(this.limitFps===void 0||e>1/this.limitFps){if(s(this,k)){const i=s(this,k).grid;if(!i)throw new Error("simulation or grid must be provided");s(this,W)&&s(this,k).step(e),s(this,B)&&s(this,B).call(this,{grid:i,deltaTime:e}),s(this,P)&&s(this,P).render(i,{resetChanges:!1,...s(this,H)}),i.resetChanges()}c(this,j,t)}}}}P=new WeakMap,H=new WeakMap,k=new WeakMap,B=new WeakMap,W=new WeakMap,T=new WeakMap,j=new WeakMap;function Et(r,t){var A,b;const{limitFps:e,renderOptions:i,children:o,initSimulation:a,onStep:d,...C}=r,w=E.useRef(null),R=E.useRef(null),S=E.useRef();E.useImperativeHandle(t,()=>R.current),E.useEffect(()=>{if(w.current&&!R.current)return R.current=new Ct({gridRenderer:w.current,simulation:a(),limitFps:e,renderOptions:i,onStep:d}),()=>{var g;(g=R.current)==null||g.destroy()}}),E.useEffect(()=>{var g;w.current&&(dt.isEqual(i,S.current)||(S.current=i,(g=R.current)==null||g.registerGridRenderer(w.current,i)))},[i]);function I(g){g.preventDefault()}return et.jsx(wt,{ref:w,grid:(b=(A=R.current)==null?void 0:A.simulation)==null?void 0:b.grid,children:o,onContextMenu:I,...C})}const kt=E.forwardRef(Et);export{xt as C,nt as G,zt as S,l as V,kt as a,st as b,mt as n,ft as u};
